var data=
        [
            [
                {dt:"常用的交互元素",
                dl:["内容交互元素","状态交互元素"],
                text:[
                "<h3>1.details</h3>details标签用于描述文档或文档某个部分的细节。<textarea id='textarea' cols='50' rows='10'><details><summary>summary标题</summary>这里显示detail内容</details></textarea><button style='background:#990000;padding:5px 10px;color:#fff;' onclick='move()'>TIY</button><table border=1 cellspacing=0 width=600 height=100 id='table' cmpt='X-X-O-O'></table><table border=1 cellspacing=0 width=600><tr><td>属性</td><td>值</td><td>描述</td></tr><tr><td>open</td><td>open</td><td>控制details内容是否显示</td></tr><tr><td>subject</td><td>sub_id</td><td>设置元素所对应的项目ID号</td></tr><tr><td>darggable</td><td>true/false</td><td>是否可以拖动，默认为false</td></tr><table>","<h3>1.progress</h3>显示进度元素<progress id='progress' max=100 value=30></progress><table width=600 border=1 cellspacing=0><tr><td>属性</td><td>值</td><td>描述</td></tr><tr><td>max</td><td>number类型</td><td>设置进度的最大值</td></tr><tr><td>value</td><td>number类型</td><td>设置当前值</td></tr></table><table width=600 id='table' border=1 cellspacing=0 cmpt='X-O-O-O'></table><h3>2.meter</h3>用于表示范围中的值，与progress相比多了最小值<meter min=0 max=10 value=7 low=3 high=8 optimum=7></meter><table width=600 border=1 cellspacing=0><tr><td>属性</td><td>值</td><td>描述</td></tr><tr><td>value</td><td>Number类型</td><td>实际值</td></tr><tr><td>min</td><td>Number类型</td><td>范围的最低值</td></tr><tr><td>max</td><td>Number类型</td><td>范围的最高值</td></tr><tr><td>low</td><td>Number类型</td><td>可接受的较低值，当value低于此值是颜色表现为亚黄色</td></tr><tr><td>high</td><td>Number类型</td><td>可接受的较高值，当value高于此值是颜色表现为亚黄色</td></tr><tr><td>optimum</td><td>Number类型</td><td>最优值</td></tr></table>"],
                name:"HTML5"
                },
                {dt:"HTML5中重要的元素",
                dl:["节点","镶嵌内容","公共属性"],
                text:[
                "<h3>1.section</h3>用于标记文档的区域或者段落<section style='background:#ccffcc;border:2px dashed #6666ff;width:200px;height:200px'>这是section标签</section><table width=600 border=1 cellspacing=0><tr><td>属性</td><td>值</td><td>描述</td></tr><tr><td>cite</td><td>url</td><td>section内容引用的web地址</td></tr><tr><td>hidden</td><td>true，false</td><td>控制元素显示隐藏</td></tr><tr><td>draggable</td><td>true，false</td><td>是否可以拖拽</td></tr></table><h3>2.nav</h3>用于页面导航<nav style='height:70px;width:450px;background:#ccffcc;line-height:70px;text-align:center'><a style='margin:0px 50px' href='#'>首页</a><a style='margin:0px 50px' href='#'>JS</a><a href='#'>JQ</a><a style='margin:0px 50px' href='#'>HTML5</a></nav><h3>3.hgroup</h3>用于包含H标签<hgroup style='background:#ccffff'><h2 xxxxstyle='background:#ffff99'>h2标签</h2><h3 style='background:#ffcc99'>h3标签</h3><h4 style='background:#ff9999'>h4标签</h4><h5 style='background:#ff66cc'>h5标签</h5></hgroup><h3>4.aside</h3>作为侧边栏显示<aside style='background:#ccccff;height:120px;width:90px'><ul style='height:120px;width:90px;list-style:none'><li style='height:29px;border-bottom:1px solid #cc0066'>标题一</li><li style='height:29px;border-bottom:1px solid #cc0066'>标题二</li><li style='height:29px;border-bottom:1px solid #cc0066'>标题三</li><li style='height:29px;border-bottom:1px solid #cc0066'>标题四</li></ul></aside><h3>5.新的布局</h3>article 内容放文章</br>header 头部</br>nav 导航</br>section 类似div，定义一个区域</br>aside 侧边栏</br>hgroup 存放H类标签</br>figure 媒体内容</br>figcaption 标题</br>footer 尾部</br><img src='note/lay.png' />","<h3>1.iframe</h3>iframe用于在页面中创建包含另一个文档框架<iframe style='height:1000px;width:650px;background:#ffffcc;display:block' src='http://www.w3school.com.cn/'></iframe>","<h3>1.draggable</h3>draggable属性用来控制元素是否可以拖拽<div style='height:50px;width:250px;background:#ccffff;line-height:50px;font-size:20px;border:1px solid red' draggable='true'>这是一段可以拖拽的文字</div><table id='table'  width=600 border=1 cellspacing=0 cmpt='X-X-O-O'></table><h3>2.hidden</h3>用于元素的隐藏,此属性是单标签属性<h4>元素的隐藏属性</h4><input type='radio' name='btn' checked onclick='hid(1)'>显示</input><input type='radio' name='btn' onclick='hid(0)'>隐藏</input><div id='_div' style='background:#ccffff;border:1px solid red;height:20px;width:190px'>划船不用桨，一生全靠浪</div><h3>3.contenteditable</h3>当此属性为true时，可以手动修改元素内的内容<h4>元素的隐藏属性</h4><div id='_div2' contenteditable='true' style='background:#ccffff;border:1px solid red;height:50px;width:190px'>划船不用桨，一生全靠浪</div><button onclick='contenteditable()' style='background:#990000;padding:5px 10px;color:#fff;'>保存</button>"],
                name:"HTML5"
                },
                {dt:"智能表单",
                dl:["新的input","新增的表单元素"],
                text:[
                "<h3>1.form的解放</h3>以往表单提交是通过form标签的嵌套完成的，而HTML5不需要嵌套，input通过form属性关联ID来完成<img src='note/input.png' width=650 style='display:block' /><h3>2.新的input类型</h3><form action='http://www.baidu.com' method='get'>邮箱：<input type='email'></input></br>网址：<input type='url'></input></br>数字：<input type='number'></input></br>日期：<input type='date'></input></br>时间：<input type='time'></input></br>周：<input type='week'></input></br>月：<input type='month'></input></br><input type='submit'></input></form>其中email、url、numer当不为空时，会自动验证是否符合规则；</br>数轴：<input type='range' min=0 max=100 value=50></input></br>搜索框：<input type='search'></input><h3>3.重要的表单属性</h3>required：不能为空<form action='http://www.baidu.com' method='get'>邮箱：<input type='email' required></input><input type='submit'></input><form></br>placeholder:提示字段<input type='email' placeholder='请填写邮箱'></input></br>autofocus:自动聚焦<input type='email' autofocus></input></br>pattern:正则<form action='http://www.baidu.com' method='get'><input type='text' pattern='\d+' placeholder='请输出数字'></input><input type='submit'></input></form>","<h3>1.datalist</h3><div>推荐搜索项，input通过list关联datalist的ID来实现</div><input list='list' type='text'></input><datalist id='list'><option>选项一</option><option>选项二</option><option>选项三</option></datalist><textarea id='textarea' cols='50' rows='10'><input list='list' type='text'></input><datalist id='list'><option>选项一</option><option>选项二</option><option>选项三</option></datalist></textarea><button style='background:#990000;padding:5px 10px;color:#fff;' onclick='move()'>TIY</button>"],
                name:"HTML5"
                },
                {dt:"HTML5文件操作",
                dl:["选择文件","FileReader读取文件","读取文件时错误与异常"],
                text:[
                "<h3>1.file</h3><div>通过input type=file来选择文件，如果设置属性multiple=true则可以选择多个文件</div><input id='files' type='file' multiple='true' onchange='fs()'></input></br>每一个上传的对象都保存在该input的fileList数组当中,通过.files来访问，fileList的属性如下<img src='note/file.jpg' width=650 /></br>lastModifiedDate：最后上传时间</br>name：文件名</br>type：文件类型</br>size：文件大小单位是B</br><h3>2.accept</h3><div>用于过滤文件类型,Internet Explorer 9 以及更早的版本不支持 input 标签的 accept 属性。如需规定多个值，请使用逗号分隔（比如accept='audio/*,video/*,image/*'）。</div> <table width=600 border=1 cellspacing=0><tr><td>值</td><td>描述</td></tr><tr><td>audio/*</td><td>接受所有的声音文件。</td></tr><tr><td>video/*</td><td>接受所有的视频文件。</td></tr><tr><td>image/*</td><td>接受所有的图片文件。</td></tr></table></br><input type='file' accept='image/*'></input>只接受图片文件","<h3>1.使用FileReader接口</h3><div>FileReader提供了一个异步API，从浏览器主线程中异步访问文件系统中的数据，访问文件时必须调用FileReader的构造函数，此接口中有很多方法，如下</div><h4>1.1 readAsDataURL预览图片<h4/><div style='background:#99cccc;border:2px dashed #333399;width:600px'>function readImg(obj){</br>&nbspvar imgUrl='';</br>&nbspvar ul=document.getElementById('ul1');</br>&nbspfor(var i=0;i<obj.files.length;i++){</br>&nbsp&nbspvar tmp=obj.files[i];</br>&nbsp&nbspvar readF=new FileReader();</br>&nbsp&nbspreadF.readAsDataURL(tmp);</br>&nbsp&nbspreadF.onload=function(e){</br>&nbsp&nbsp&nbspimgUrl= src=e.target.result</br>&nbsp&nbsp&nbspul.innerHTML+=imgUrl;</br>&nbsp&nbsp}</br>&nbsp}</br>}</br></div><input type='file' onchange='readImg(this)' multiple='true'></input><ul style='list-style:none;width:600px;' id='ul1'></ul><h4>1.2 readAsText读取文本文件<h4/><div style='background:#99cccc;border:2px dashed #333399;width:600px'>function readImg(obj){</br>&nbspvar textR='';</br>&nbspvar div=document.getElementById('div1');</br>&nbspfor(var i=0;i<obj.files.length;i++){</br>&nbsp&nbspvar tmp=obj.files[i];</br>&nbsp&nbspvar readF=new FileReader();</br>&nbsp&nbspreadF.readAsText(obj.files[i]);</br>&nbsp&nbspreadF.onload=function(e){</br>&nbsp&nbsp&nbsptextR=e.target.result;</br>&nbsp&nbsp&nbspdiv1.innerHTML=textR;;</br>&nbsp&nbsp}</br>&nbsp}</br>}</br></div><input type='file' onchange='readText(this)' multiple='true'></input><div style='background:#ffffcc;width:600px;border:1px solid #333399' id='div1'><h5 style='text-align:center'>文本内容</h5></div><h4>1.3 FileReader事件的监听<h4/><div>fileReader中提供了完整的事件处理机制</div><table width=600 border=1 cellspacing=0><tr><td>值</td><td>描述</td></tr><tr><td>onloadstart</td><td>开始读取数据时</td></tr><tr><td>onloadend</td><td>请求操作成功时，无论是否成功都会触发该事件</td></tr><tr><td>onprogress</td><td>正在读取数据</td></tr><tr><td>onabort</td><td>读取数据终止时</td></tr><tr><td>onerror</td><td>读取数据失败时</td></tr></table><div style='background:#99cccc;border:2px dashed #333399;width:600px'>function checkdom(obj){</br>&nbspvar span=document.getElementById('span1');</br>&nbspfor(var i=0;i<obj.files.length;i++){</br>&nbsp&nbspvar readF=new FileReader();</br>&nbsp&nbspreadF.readAsText(obj.files[i]);</br>&nbsp&nbspreadF.onload=function(e){</br>&nbsp&nbsp&nbsp&nbspspan.innerHTML+='读取文件成功</br>'</br>&nbsp&nbsp}</br>&nbsp&nbspreadF.onloadstart=function(e){</br>&nbsp&nbsp&nbsp&nbspspan.innerHTML+='开始读取数据</br>'</br>&nbsp&nbsp}</br>&nbsp&nbspreadF.onloadend=function(e){</br>&nbsp&nbsp&nbsp&nbspspan.innerHTML+='数据读取完毕</br>'</br>&nbsp&nbsp}</br>&nbsp&nbspreadF.onprogress+=function(e){</br>&nbsp&nbsp&nbsp&nbspspan.innerHTML='正在读取数据中</br>'</br>&nbsp&nbsp}</br>&nbsp}</br>}</br></div><input type='file' onchange='checkdom(this)' multiple='true'></input><span style='background:#ffffcc;width:150px;display:block;height:90px;border:1px solid #333399' id='span1'></span>","<h3>1.FileReader中onerror事件<h3/><div>FileReader中onerror事件中的e.target.error.code保存着错误参数</div><div style='background:#99cccc;border:2px dashed #333399;width:600px'>function readImg(obj){</br>&nbsp&nbspfor(var i=0;i<obj.files.length;i++){</br>&nbsp&nbsp&nbsp&nbspvar tmp=obj.files[i];</br>&nbsp&nbsp&nbsp&nbspvar readF=new FileReader();</br>&nbsp&nbsp&nbsp&nbspreadF.readAsDataURL(tmp);</br>&nbsp&nbsp&nbsp&nbspreadF.onerror=function(e){</br>&nbsp&nbsp&nbsp&nbsp&nbsp&nbspalert(e.target.error.code)</br>&nbsp&nbsp&nbsp&nbsp}</br>&nbsp&nbsp}</br>}</br></div><table border=1 cellspacing=0 width=600 height=100><tr><td>错误参数</td><td>说明</td></tr><tr><td>NOT_FOUND_ERR</td><td>文件无法找到或文件已被修改</td></tr><tr><td>SECURITY_ERR</td><td>处于安全考虑，无法获取数据</td></tr><tr><td>ABORT_ERR</td><td>触发abort事件，终止读取文件</td></tr><tr><td>NOT-READABLE_ERR</td><td>由于权限原因，无法读取文件</td></tr><tr><td>ENCODING_ERR</td><td>文件太大，超过读取时地址的限制</td></tr></table>"],
                name:"HTML5"
                },
                {dt:"HTML5视频和音频",
                dl:["多媒体元素基本属性","多媒体元素常用方法","多媒体重要事件"],
                text:[
                "<h3>1.多媒体标签<h3/><div>video是H5中新增加的标签用于电影文件，其他视频流的播放。audio用于播放音乐文件、其他视频流播放。两者都有src属性用来关联文件地址</div>视频<br><video controls src='note/move.mp4'></video></br>音乐</br><audio src='note/zbr.mp3' controls></audio><h3>2.子标签source</h3><div>多媒体允许多个 source元素。source 元素可以链接不同格式的多媒体文件。source中需要填写type属性：video或者audio/格式。因为不同浏览器兼容不同格式的文件，兼容如下</div>目前，audio 元素支持三种音频格式：<img src='note/audio.jpg' style='display:block' width=600 />当前，video 元素支持三种视频格式：<img src='note/video.jpg' style='display:block' width=600 /><h3>3.width和height属性</h3><div>width和height属性只适用于video标签，表示设置视频的大小，如果没有设置，默认为视频本身大小</div><h3>4.controls</h3><div>controls属性是浏览器默认控制条工具，为单标签属性，当存在时，为多媒体元素自动添加控制条，不同浏览器的控制条样式不一。</div><div>鼠标移入显示，移除隐藏控制条</div><video onmouseover='controlsshow(this)' onmouseout='controlshide(this)'src='note/move.mp4'></video><h3>5.poster属性</h3><div>poster适用在video标签当中，存放图片的url，表示视频播放前显示的内容，而不是默认显示视频文件的第一帧。</div><video src='note/move.mp4' poster='note/bhsd.jpg' controls></video><h3>6.networkState属性</h3><div>netWorkState属性可以返回视频文件的网络状态，当浏览器读取视频时，会触发progress事件。通过该事件可以获取该视频被打开的过程中的不同阶段网络状态</div><table border=1 cellspacing=0 width=600 height=100><tr><td>返回值</td><td>说明</td></tr><tr><td>0</td><td>数据加载初始化</td></tr><tr><td>1</td><td>数据加载完成请求播放</td></tr><tr><td>2</td><td>数据正在加载中</td></tr><tr><td>3</td><td>加载出错，原因是没有支持的编码格式</td></tr></table><h3>6.其他属性</h3><div>autoplay和Loop</br>autoplay是否自动播放，为单标签属性</br>loop循环播放次数，可填写数字类型或者loop(无限循环)</div><div>currentTime、startTime、duration属性</br>&nbsp&nbspcurrentTime返回的是当前播放时间，也可以赋值</br>&nbsp&nbspstartTime可以设置开始播放时间，默认为0</br>&nbsp&nbspduration返回的是视频总体播放时间</div><div>volume和muted</div><div>&nbsp&nbspvolume返回的是音量范围是0-1，可获取可赋值</br>&nbsp&nbspmuted表示是否静音，true为静音，false为不静音</div>","<h3>1.播放方法</h3><div>video标签有很多API，播放play()和暂停paused()</div><div style='background:#99cccc;border:2px dashed #333399;width:600px'>function play(obj){</br>&nbsp&nbspvar v=document.getElementById('v');</br>&nbsp&nbspif(obj.innerHTML=='播放'){obj.innerHTML='暂停';v.play()}</br>&nbsp&nbspelse{obj.innerHTML='播放';v.pause()}</br>}</br></div><video id='v' src='note/move.mp4'></video><button onclick='play(this)'>播放</button>"," <h3>1.TimeUpDate</h3><div>timeupdate是一个十分常用的事件，在多媒体播放过程当中如果播放位置发生变化就会触发该事件</br>利用timeupdate动态获取播放时间</div><video src='note/move.mp4' autoplay loop='loop' onTimeUpDate='timeupdate(this)'></video><span id='s' style='background:#cccccc;border:1px solid #000'></span>"],
                name:"HTML5"
                },
                {dt:"Canvas画布",
                dl:["画布的基础知识","在画布中使用路径","对画布中图形的操作","处理画布中的图像","画布的其他应用"],
                text:[
                "<h3>1.canvas标签</h3><div>canvas标签是页面中的一块画布，在该画布上可以绘制图形。</br>创建canvas标签页十分简单，和其他元素相同需要加一个id号和长宽即可</br>《canvas id=‘cv’ height=300 width=300》《/canvas》</br>在使用canvasAPI时，首先要获取canvas元素，然后取得上下文环境getContext（‘2d’）</br>绘制矩形</br><div style='background:#99cccc;border:2px dashed #333399;width:600px'>var exe=document.getElementById('cv1').getContext('2d');</br>exe.fillStyle='red';</br>exe.fillRect(30,30,100,100);</br></div>fill表示填充，fillStyle表示填充颜色,fillRect表示填充矩形，参数分别表示距离左、上分多少像素，长宽多少像素<img src='note/cv1.jpg' width=300 height=300 style='display:block' /><div>stroke表示描边，strokeStyle表示描边颜色，lineWidth可以设置线条粗细，strokeRect表示描边矩形，参数分别表示距离左、上分多少像素，长宽多少像素。</div><div style='background:#99cccc;border:2px dashed #333399;width:600px'>var exe=document.getElementById('cv1').getContext('2d');</br>exe.strokeStyle='red';</br>exe.lineWidth='10';</br>exe.strokeRect(30,30,100,100);</br></div><img src='note/cv2.jpg' width=300 height=300 style='display:block' /><div>绘制渐变色</div><div>绘制渐变色需要创建createLinearGradient（）对象，参数分别表示渐变色开始横纵坐标，结束时横纵坐标，然后调用该对象的addColorStop（）方法，参数表示0或1、颜色。</div><div style='background:#99cccc;border:2px dashed #333399;width:600px'>var exe=document.getElementById('cv1').getContext('2d');</br>var gnt1=exe.createLinearGradient(30,30,130,130);</br>gnt1.addColorStop(0,'#ff99cc');</br>gnt1.addColorStop(1,'#ffcc66');</br>exe.fillStyle=gnt1;</br>exe.fillRect(30,30,100,100);</br></div><img src='note/cv3.jpg' width=300 height=300 style='display:block' /></div>","<h3>1.moveTo与lineTo</h3><div>在canvas中可以调用该元素绘制直线与圆</br>在使用moveTo和lineTO开始和结束时一般会调用beginPath和closePath来闭合路径</br>绘制折线</br>moveto表示起点位置。lineto表示转折点位置，lineWidth表示线段粗细,路径布置完毕时调用stroke（）方法即可绘制<div style='background:#99cccc;border:2px dashed #333399;width:600px'>var exe=document.getElementById('cv1').getContext('2d');</br>exe.beginPath();</br>exe.moveTo(10,10);</br>exe.lineTo(160,140);</br>exe.lineTo(10,290);</br>exe.stroke();</br>exe.closePath();</br></div><img src='note/cv5.jpg' width=300 height=300 style='display:block' /><div>绘制圆</div><div>需要调用arc方法，参数分别表示圆心的横纵坐标，半径，开始角度，结束角度，是否顺时针绘制</div><div style='background:#99cccc;border:2px dashed #333399;width:600px'>var exe=document.getElementById('cv1').getContext('2d');</br>exe.beginPath();</br>exe.arc(100,100,50,0,Math.PI*2,false);</br>exe.fillStyle='#3399ff';</br>exe.fill();</br>exe.closePath();</br></div><img src='note/cv6.jpg' width=300 height=300 style='display:block' /></div>","<h3>1.图形的旋转、移动和缩放</h3><div>在canvas中有rotate、translate和scale可以控制元素的图形的旋转、移动和缩放,但是一般这些方法都是讲canvas画布旋转缩放和移动的，如果需要操作画布中的图形，需要配合save（）和restore方法，通过设置translate参数设置为画布中心然后操作。</br><button onclick='cv_move()'>移动</button>&nbsp&nbsp&nbsp<button onclick='cv_scale()'>缩放</button>&nbsp&nbsp&nbsp<button onclick='cv_rotate()'>旋转</button><canvas id='cv1' width=300 height=300 style='background:#ccccff;display:block'></canvas><img src='note/cv7.jpg' style='display:block' />","<h3>1.绘制图像</h3><div>canvas中drawImage方法可以将页面存在的元素绘制在画布当中，参数一般可以填写3个或着5个或者9个，推荐填写5个设置的是image对象、起点横纵坐标以及宽高。</div><div style='background:#99cccc;border:2px dashed #333399;width:600px'>var exe=document.getElementById('cv1').getContext('2d');</br>var img=new Image();</br>img.src='h5.jpg';</br>exe.drawImage(img,10,10,280,280);</br></div><img src='note/8.jpg' width=300 height=300 style='display:block' /><h3>2.切割</h3><div>canvas中clip，该方法没有参数，使用路径完毕之后调用该方法可以实现切割。</div><div style='background:#99cccc;border:2px dashed #333399;width:600px'>var exe=document.getElementById('cv1').getContext('2d');</br>var img=new Image();</br>img.src='h5.jpg';</br>exe.beginPath();</br>exe.arc(150,150,130,0,360,false);</br>exe.closePath();</br>exe.stroke();</br>exe.clip();</br>exe.drawImage(img,10,10,280,280);</br></div><img src='note/cv9.jpg' width=300 height=300 style='display:block' />","<h3>1.绘制文字</h3><div>canvas中fillText方法可以绘制文字，参数分别为字符串、开始横纵坐标。</div><div>绘制文字有许多重要的属性</div><table border=1 cellspacing=0 width=600 height=100><tr><td>属性</td><td>描述</td></tr><tr><td>font</td><td>可以设置css样式字体中的任何值，如字体要是名称大小粗细等</td></tr><tr><td>textAlign</td><td>文本对其方式start、end、left、right、center</td></tr><tr><td>textBaseline</td><td>相对起点位置：top、bottom、middle</td></tr></table><div style='background:#99cccc;border:2px dashed #333399;width:600px'>var exe=document.getElementById('cv1').getContext('2d');</br>exe.font='80px bold';</br>exe.textBaseline='top';</br>exe.fillStyle='#cc0066';</br>exe.fillText('HTML5',50,100);</br></div><img src='note/cv10.jpg' width=300 height=300 style='display:block' />"],
                name:"HTML5"
                },
                {dt:"HTML5数据存储",
                dl:["web Storage存储","localStorage","web SQL数据库"],
                text:[
                "<h3>1.web Storage</h3><div>web Storage存储方式是用于临时或者永久保存客户端少量数据，不需要与服务端交互，主要有2中存储方式：</br>sessionStorage(临时性保存会话数据)</br>localStorage(在客户端长期保存数据)</div><h3>1.1 sessionStorage</h3><div>使用session保存的数据时间非常短，只要关闭浏览器session数据就全部丢失。</br>使用方法：调用sessionStorage下面的setItem方法：</br>sessionStorage.setItem(key,value)；</br>获取sessionStorage：调用其下getItem方法</br>sessionStorage.getItem(key);</div><input type='text' id='ss'></input><button onclick='savess()'>保存</button><button onclick='getss()'>读取</button><img style='display:block' src='note/ss1.jpg' /><h3>1.2 localStorage</h3><div>localStorage用来长久保存数据。</br>使用方法：调用localStorage下面的setItem方法：</br>localStorage.setItem(key,value)；</br>获取localStorage：调用其下getItem方法</br>localStorage.getItem(key);</br>清除数据：localStorge.removeItem(key);</div>","<h3>1.清空localStorage数据</h3><div>removeItem()方法可以只能逐条清除数据，clear()方法是将所有本地数据清空。使用方法如下:</br>localStorage.clear();</div><h3>2.遍历localStorage数据</h3><div>需要遍历localStorage数据需要用到另外2个属性length和key。前者表示local的总量，后者表示保存数据的键项名,key常与索引号配合使用用来获取值。</div><img src='note/local.jpg' style='display:block' /><h3>3.使用json对象存取数据</h3><div>通过localStorage数据与json对象的转换，可以存储更多数据。</br>原理解析：新建一个空对象，在空对象中设置相应的属性，然后通过JSON.stringify()方法将此对象转化成字符串，然后设置setItem（jsondata,JSON.stringify()）;</div><img src='note/json.jpg' style='display:block' width=650 />","<h3>1.web SQL数据库基础</h3><div>虽然web Storage方法适用于主流浏览器和设备，但是存在局限性，存储空间最多只能存5MB，所有推出了WEB SQL，他内置SQLite数据库通过调用executeSql()方法来实现</div><h3>1.1 创建数据库</h3><div>web dataBase是通过事务驱动，实现对数据的管理，所以支持多浏览器并发操作，而不会发生存储冲突。首先创建数据库是调用openDatabase(数据库名称，版本号，对数据的描述，大小单位为字节例如1M为1024*1024，回调函数表示创建成功时候调用的函数).</div><button onclick='createDb()'>创建数据库</button>&nbsp&nbsp&nbsp<button onclick='testDb()'>连接测试</button><div id='Dbshow' style='text-align:center;height:30px;width:200px;border:3px dashed #6666ff;background:#cccccc;line-height:30px'></div><img src='note/db1.jpg' style='display:block' width=650 /><h3>1.2 创建表格</h3><div>数据库创建之后，通过调用该对象的transaction方法执行一系列操作,transaction(需要执行数据库语句,失败时回调函数,成功时回调函数)。数据库语句函数function(tx){tx.executeSql()}。executeSql(‘create table if not exists stu(id real unique,name text,sex text)’)，create table if not exists stu(id real unique,name text,sex text)表示如果没有stu的表格就创建里面的内容是id唯一标识，name文本类型sex文本类型</div><button onclick='createTable()'>创建表格</button><img src='note/db2.jpg' style='display:block' width=650 /><h3>1.3 插入数据</h3><div>插入数据同样是执行executeSql('insert into stu values(?,?,?)',['id参数','姓名参数','性别参数'],成功回调函数,失败回调函数)</div><button onclick='insertDb()'>插入一条学生数据</button><img src='note/db3.jpg' style='display:block' width=650 /><h3>1.4 数据的管理</h3><div>executeSql还有‘select’，‘update’，‘delete’功能。</div><button onclick='updataDb()'>更新学生数据</button><button onclick='selectDb()'>查询学生数据</button><button onclick='deleteDb()'>删除学生数据</button></br><button onclick='deletaTable()'>删除数据表</button><button onclick='deletaBase()'>删除数据库</button><img src='note/db4.jpg' style='display:block' width=650 /><img src='note/db5.jpg' style='display:block' width=650 />"],
                name:"HTML5"
                },
                {dt:"HTML5中的其他应用型API",
                dl:["web Sockets API","Geolocation API","web Workers API"],
                text:[
                "<h3>1.postMessage</h3><div>JS处于安全考虑，不允许跨域，所以给不同区域页面的数据访问带来了障碍，但是在H5中可以利用postMessage方法在两个不同的页面之间实现数据的接受与发送。</div><div>如何使用postMessage：</br>需要调用对象的postMessage方法，格式如下：</br>otherWindow.postMessage(发送的内容，发送数据的URL)</div><img src='note/pm.jpg' style='display:block' width=650 />","<h3>1.geolocation</h3><div>geolocation用来获取用户的地理位置信息，需要调用getCurrentPosition()方法</br>如果需要获取地理位置信息需要访问到window.navigator中geolocation属性调用getCurrentPosition()方法.格式如下</br>window.navigator.geolocation.getCurrentPostion(获取成功是回调操作,获取失败是回调函数,第三个参数是选填参数格式为JSON用来保存属性)</br>error对象的code属性</br><table border=1 cellspacing=0 width=600 height=100><tr><td>属性值</td><td>描述</td></tr><tr><td>0</td><td>位置错误信息</td></tr><tr><td>1</td><td>操作被拒绝</td></tr><tr><td>2</td><td>没有获取争取的地理位置信息</td></tr><tr><td>3</td><td>获取位置操作超时</td></tr></table></br>包含的属性值</br><table border=1 cellspacing=0 width=600 height=100><tr><td>属性</td><td>描述</td></tr><tr><td>timeout</td><td>设置多少毫秒之后触发超时失败回调函数errorcode 3</td></tr><tr><td>maximumAge</td><td>多长时间重新获取位置</td></tr><tr><td>enableHighAccuracy</td><td>布尔值,表示是否获取精确位置</td></tr></table></div><div>在成功回调函数当中参数的有三个重要的属性timestamp、coords和address，timestamp表示获取地理位置的时间。coords保存着重要的地理信息.address表示地址</div><button onclick='getpostion()'>获取位置</button><div id='gpshow' style='text-align:center;height:300px;width:200px;border:3px dashed #6666ff;background:#cccccc;line-height:30px'></div><img src='note/geo.jpg' style='display:block' width=650 />","<h3>1.web workers</h3><div>web workers可以将JS代码分割成若干块，分别有不同的后台线程负责执行,是为了后台计算提供完全隔离的计算方式，所以不可以访问DOM API，不可以访问window object，不可以访问document object，实现多线程操作</br>如何使用worker对象：</br>var w=new Worker('js文件')</br>需要结合message事件通信</br>addEvent('message',function(event){},false)</br>worker使用postMessage方法发送消息:</br>w.postMessage(data)</br>worker引入文件</br><img src='note/w2.jpg' style='display:block' width=650 />页面执行代码</br><img src='note/w1.jpg' style='display:block' width=650 /></div>"],
                name:"HTML5"
                }
            ],[
                {dt:"JS基础",
                dl:["js中的类型、值和变量","数组","函数","JS中的面向对象"],
                text:[
                "<h3>1.1 数字类型</h3><details open><summary>JS中的算术运算方法</summary><p>Math.pow(2,10)//2的10次方</br>Math.round(.6)//四舍五入输出1</br>Math.ceil(.6)//向上取整输出1</br>Math.floor(.6)//向下取整输出0</br>Math.abs(-5)//绝对值输出5</br>Math.max(1,5,7)//去最大值输出7</br>Math.min(1,5,7)//取最小值输出1</br>Math.random()//输出0到1的随机数</br>Math.PI()//输出圆周率</br>Math.sqrt(4)//4的平方根</p></details><details open><summary>关于浮点数</summary><p>JS中关于浮点数存在一个小小的bug，在用浮点数相减时，结果相同的两个数JS认为是不等的:</br>var x=.3-.2;</br>var y=.2-.1</br>x==y//输出false</p></details><details open><summary>日期和事件</summary><p>js中存在构造函数Date()用来返回事件</br>var then=new Date(2012,11,12)//设置时间为2012年12月12日</br>var now=new Date()//获取现在的时间</br>var c=now-then//获取现在与过去时间的差值单位为毫秒</br>var year=now.getFullYear()//获取现在的年份</br>var moon=now.getMonth()+1//获取现在的月份，需要加1</br>var date=now.getDate()//获取天数</br>var day=now.getDay()//获取星期几,0是星期日</br>var h=now.getHours()//获取小时</br></p></details><h3>1.2 文本类型</h3><details open><summary>字符串的属性和方法</summary><p>var s='hello world' //定义一个字符串</br>s.length //返回字符串的长度</br>s.charAt(0) //返回字符串第1个位置的字符</br>s.substring(2) //截取从第3个位置到最后的字符串</br>s.slice(2) //截取从第3个位置到最后的字符串</br>s.substr(2) //截取从第3个位置到最后的字符串</br>s.substring(2,4) //截取从第3个位置到第5个位置之前的字符串</br>s.slice(2,4) //截取从第3个位置到第5个位置之前的字符串</br>s.substr(2,4) //截取从第3个位置的4个字符串</br>s.slice(-3) //截取后面3个字符串</br>s.substr(-3) //截取后面3个字符串</br>s.indexOf('s') //首次出现s的位置</br>s.indexOf(5,'s') //从第6个位置开始查找出现s的位置</br>s.lastIndexOf('s') //最后出现s的位置</br>s.split(' ') //分割内容前后的字符串为数组</br>s.replace('h','H') //将字符串h替换成H</br>s.toUpperCase() //转成大写</br>s.toLowerCase() //转小写</p></details><h3>1.3 布尔类型</h3><details open><summary>特殊的布尔类型</summary><p>0==false</br>''==false</br>undefined==false</br>null==false</br>[]==false</br>其他基本上都是真值</p></details><h3>1.4 null和undefined</h3><details open><summary>null和undefined</summary><p>null的typeof为object，也就是说null是一直特殊的对象值，含义是非对象</br>undefined表示对象或者属性不存在</br>null==undefined //true</br>null===undefined //false</p></details><h3>1.5 类型的转换</h3><details open><summary>转换的相等性</summary><p>在使用==比较时JS会自动将两边的类型转换成同一种类型然后在进行比较</br>'0'==0 //比较前会将字符串转化成数字</br>'0'==false //会将两者转化成数字比较</br>0==fasle //会将布尔值转化成数字进行比较</p></details><details open><summary>显示类型转换</summary><p>Number('3') //转换成数字类型3</br>String(fasle) //转成字符串‘fasle’</br>Boolean([]) //true</br>toString还可以进行进制转换：var n=17;n.toString(2); //将17转化成二进制</br>parseInt('3.5 sdfaads') //输出3，只能解析开头是数字的字符串，如果开头不是数字则输出NaN</br>parseFloat('3.5556 dsafds') //输出3.5556</br></p></details><details open><summary>对象转化成原始值</summary><p>所有的对象都继承了2个转化方法，第一个是toString();他的作用是返回这个对象的字符串:</br>({x:1,y:2}).toString() //'[object Object]'</br>[1,2,3].toString() //'1,2,3'</br>另一个是valueOf():将对象转化成他的原始值</br>var now=new Date();now.valueOf() //会输出从1970以来的毫秒数</p></details>","<h3>数组的操作</h3><details open><summary>数组简单的创建方法</summary><p>var arr=[] //创建一个空数组</br>var arr=[1,2,5,6] //创建一个长度为4个数组</br>var arr=[1,{x:1},true,'a',] //创建不同类型的数组，并且以逗号结尾，数组允许与逗号结尾</br>var arr=[,,] //创建有2个元素的数组，值都是undefined</p></details><h3>1.2 数组的读写</h3><details open><summary>数组使用下标[]来访问</summary><p>var arr=[];arr[0]=1 //首先创建一个空数组，然后为其第一个添加数字1</br>数组的下标[]是可以解析字符串和浮点的</br>a[1.23]=1 //为a创建一个属性为1.23值为1</br>a['999']=1 //设置数组第1000个元素为1</br>a[1.00] //设置第二个元素为1</p></details><details open><summary>数组元素添加和删除</summary><p>var a=[];</br>a[0]=1 //通过下标来赋值的简单方法</br>a.push('2') //push方法是在数组最后添加内容</br>删除可以使用delete方法但是被删除后该位置依然存在只是值为undefined，数组的长度并未改变</p></details><details open><summary>数组的方法</summary><p>join():通过内容将数组连接成字符串，var a=[1,2,3]</br>a.join() //‘1,2,3’</br>a.join(' ') //‘1 2 3’</br>a.join('') //'123'</br>reverse()：返回一个倒序数组</br>a.reverse() //[3,2,1]</br>sort():将数组元素内首字母从小到大排序</br>var a=['b','a','c']</br>a.sort() //['a','b','c']</br>sort还可以传入比较函数进行特定的排序<img src='note/sort.png' style='display:block' />concat():创建并返回新数组：<img src='note/concat.png' style='display:block' />slice():返回截取数组片段<img src='note/slice.png' style='display:block' />splice()：数组的删除，可接收2个参数，第一个是开始删除的位置，第二个是删除的个数<img src='note/splice.png' style='display:block' />pop()：删除数组的最后一个元素使数组长度减一,并且返回他的删除值</br>var a=[1,2,3,4]</br>a.pop()//返回4，a是[1,2,3]</br>unshift和shift:分别表示在数组开头添加和删除元素<img src='note/shift.png' style='display:block' /></p></details>","<details open><summary>函数的定义</summary><p>每一种函数的创建都调用了new Function这个构造函数，从而会继承函数的属性和方法</br>div.onclick=function(){//匿名函数}</br>function fN(){//创建有名函数}</br>var a=function(){//将函数定义在var当中}</br>a();//函数的调用</br>var a=(function(){return 1})()//这里会a就是这个函数的返回值而不是此函数</p></details><details open><summary>函数的调用</summary><p>function fn(){//}</br>fn()//函数名+()是最基本的调用方法</br>方法的调用:保存在对象属性里的函数叫做方法，假设有一个函数f，要给o的m属性添加这个方法并且调用</br>o.m=f;</br>o.m()</b>链式调用：如果在函数最后添加return this就可以实现链式调用，JQ就是最经典的链式调用</br>构造函数的调用：var o=new Object();//创建一个空对象</br>var o=new Object;//如果没有形参括号可以省略</br>间接调用：使用call或者apply方法：两者区别在于call传入2个参数第一个是上下文第二个是参数列表，apply传入第一个参数是上下文而后面的参数是数组的形式将参数传入</p></details><details open><summary>函数实参和形参</summary><p>形参出现在函数定义中，在整个函数体内都可以使用， 离开该函数则不能使用。实参是指函数调用时传入的实际参数，arguments已数组的形式用来获取传入参数 <img src='note/xcsc.png' style='display:block' />作为命名空间的函数</br>(function zone(){</br>&nbsp&nbsp&nbsp&nbsp//模块化代码,其中所有的变量都是局部变量会不污染全局变量</br>})()</p></details><details open><summary>闭包</summary><p>函数对象可以通过作用域链相互关联起来，函数体内部变量都会保存在函数的作用域内，这种特性称之为闭包</br>//作用域链，函数中会有scope属性包含上下文的变量；形式是数组，使用闭包可以延长作用域，但是会占用更多的内存；</br>//闭包的变量带来的问题 ，二级函数中访问到的变量值是一级中的值；</br><img src='note/bb.png' style='display:block' />this的指向问题<img src='note/this.png' style='display:block' /></p></details><details open><summary>函数的属性和方法</summary><p>length:会返回函数传入实参的个数</br>prototype属性:这个属性指向对象的引用，称之为原型对象，后面会进一步介绍.</br>call和apply方法：前面有介绍，这里不做强调</p></details><details open><summary>关于函数的作用域链</summary><p>当函数进行调用时，会为每一个函数添加一个SCOPE属性，通过这个属性来指向一块内存，这块内存中包含了上下文使用的变量，当在一个函数当中调用另一个函数时，新函数依然会有一个scope来指向原函数的scope和自己新增加的scope，这样的链式结构叫做作用域链</br>定义2个函数：<img src='note/scope1.png' style='display:block' />函数的作用于链指向图：<img src='note/scope2.png' style='display:block' /></p></details>","<h3>1.1 js中创建对象的方法</h3><details open><summary>new Object()</summary><p>var person=new Object()</br>person.name='jim';</br>person.age='22';</br>person.say=function(){</br>alert(this.name+this.age)</br>}</br>person.say();</br>缺点：没有类的约束，无法重复利用。</p></details><details open><summary>json</summary><p>var p2={</br>name:'peter',</br>age:12,</br>say:function(){</br>alert(this.name+this.age)</br>},</br>}</br>缺点：没有类的约束，无法重复利用。</p></details><details open><summary>工厂的方式创建</summary><p>function cp(name,age){</br>var p={};</br>p.name=name;</br>p.age=age;</br>p.say=function(){</br>alert(p.name+p.age);</br>};</br>return p;</br>}</br>var a=cp('faker',19);</br>a.say();</br>每一个对象都有一套自己的方法但是他们不相等，函数重复，占用系统资源,所有的实例化对象都会为该行为分配空间</p></details><details open><summary>通过构造函数的方式创建</summary><p>function construct(name,age){</br>this.name=name;</br>this.age=age;</br>}</br>construct.prototype.say=function(){</br>alert(this.name+this.age)</br>}</br></p></details><details open><summary>关于原型</summary><p>当函数创建时随之为止创建prototype对象，这个对象指向了该函数的原型，而当函数实例化时，该对象会有__proto__指向该构造函数的原型</br>原型的第二种写法</br>construct.prototype={</br>this.name=name,</br>this.age=age,</br>this.say:function(){</br>alert(this.name+this.age)</br>}</br>}</br>//此方法会将实例化对象constructor改写成Object（），需要手动更改.constructor=construct;</br>重写的问题<img src='note/q.png' style='display:block' /></p></details><h3>1.2面向对象的3大特征</h3><details open><summary>抽象</summary><p>在定义类的时候；将他们共有的行为和属性提取出来，形成一个模型，这类处理问题的方法叫做抽象</p></details><details open><summary>继承</summary><p>在无需重新编写原来的类的情况下它可以使用现有类的所有功能。</br>继承的几种方法:<img src='note/extend.png' style='display:block' /></p></details><details open><summary>多态</summary><p>通过父类的引用，来调用不同子类实现的方法，一个接口多种实现方式(同一个实现接口，使用不同的实例而执行不同的操作。)</br>function Master(){</br>&nbsp&nbspthis.feed=function(an,food){</br>&nbsp&nbsp&nbsp&nbspalert(an.name+food.name)</br>&nbsp&nbsp}</br>}</br>function an(name){</br>&nbsp&nbspthis.name=name;</br>}</br>function food(name){</br>&nbsp&nbspthis.name=name;</br>}</br>var a=new Master();</br>a.feed(new an('猴子'),new food('桃子'));</br>a.feed(new an('猫'),new food('鱼'));</br></p></details><details open><summary>重载</summary><p>重载：函数名一样，通过函数的参数不一样来执行不同的操作，叫做重载。</br>JS本身不支持重载，但是可以利用arguments（arguments是JavaScript里的一个内置对象，包含了调用者传递的实际参数，但不局限于函数声明所定义的参数列表，而调用时只它和数组一样有个length属性。）来模拟重载.<img src='note/reload.png' style='display:block' /></p></details>"],
                name:"原生Javascript"
                },
                {dt:"客户端的中的JS",
                dl:["window对象","DOM","事件处理","AJAX","COOKIE"],
                text:[
                "<h3>1 window</h3>window对象时JS中的全局对象，接下来就介绍window对象中有哪些属性和方法<details open><summary>定时器</summary><p>setTimeout和setInterval是用来在指定时间之后单次或者重复调用函数，他们都是JS中的全局函数，使用方法传入2个参数，第一个传入函数，第二个传入时间毫秒值 </p></details><details open><summary>location</summary><p>window对象的location属性使用的是location对象，表示当前的url<br>document对象的location属性也是指向Location对象</br>window.location===document.location //true</br></p></details><details open><summary>解析URL</summary><p>location对象的href属性用来返回url字符串</p></details><details open><summary>浏览器和屏幕信息</summary><p>appName:会返回浏览器的全称，在IE中会返回‘Microsoft Internet Explorer’，而在其他浏览器中都是返回Netscape</br>appVersion：返回浏览器版本，开头数字通常是4.0或者5.0表示它是第4代或者第五代兼容的浏览器</br>userAgent：包含了version中的所有信息和补充</br>platform：返回软件运行的操作系统</p></details><details open><summary>对话框</summary><p>alert()：向用户显示一条消息并且等待用户关闭</br>confirm():显示一条消息，要求用户点击确定或取消并且返回布尔值</br>prompt():显示一条消息，等待用户输出字符串并且返回</p></details><details open><summary>screen</summary><p>window对象的screen属性引用的是screen对象，他提供了有关显示器大小等一系列信息，screen.width和screen.height表示了显示器分辨率的宽高值</p></details><details open><summary>打开和关闭窗口</summary><p>open():可以打开新的窗口并且返回该窗口的window对象。open传入的参数:第一个填写URL如果打开空白页可以填写about：blank，第二个打开方式：_blank，_self等等，第三个填写窗口的参数：‘width=100,height=100,left=100,top=100’</br>close():关闭一个窗口,chrome会直接关闭窗口,IE会弹窗提示确认是否关闭此窗口，火狐和op则只能关闭通过open出来的窗口，不允许关闭当前窗口</p></details><details open><summary>窗体之间的关系</summary><p>parent：返回的是上一级窗口的window对象</br>top:返回的是顶级窗口的window对象</br>iframe</br>window中可以通过frames来获取当前页面的iframe元素。contentWindow用来获取子窗口的引用</p></details>","<h3>1 document</h3>window对象的document属性引用了Document对象，该对象表示窗口的内容，它是一个巨大的API核心对象，用来表示和操作文档内容<details open><summary>选取文档元素</summary><p>通过ID选取元素：document.getElmentById()</br>通过名字获取元素：document.getElmentsByName()</br>通过标签名获取元素:document.getElmentsByTagName()</br>通过css类获取元素：document.getElementsByClassName()</br>通过css选择器来获取元素：document.querySelectorAll()，此方法返回所有元素的NodeList对象，querySelector()返回匹配的第一个对象</br></p></details><details open><summary>Node方法</summary><p>childNodes:子节点 数组类型  包含文本节点 IE6-8可以正常使用，无视文本节点,其他浏览器会将文本节点包括在内<img src='note/childnodes.png' style='display:block' />解决方法：1.通过nodeType==Element来排除text节点；2：使用chilren代替childNodes，全浏览器兼容</br>ParentNode//返回父节点</br>OffsetParent//获取用来定位的父级</br>FirstChild,IE6-8 FiristElementChild,IE9+ C F O兼容//返回第一个子节点</br>lastChild,IE6-8 lastElementChild,IE9+ C F O兼容//最后第一个子节点</br>nextSibling,IE6-8nextElementSibling,IE9+ C F O//返回下一个兄弟节点</br>previousSibling,IE6-8 previousElementSibling,IE9+ C F O//返回上一个兄弟节点</p></details><details open><summary>属性赋值获取和删除</summary><p>getAttribute（‘key’）//获取值</br>setAttribute（‘key’，‘33’）//设置key属性值</br>removeAttribute（‘key’）//移除值</br></p></details><details open><summary>dom增删改查</summary><p>创建:createElement(“标签名”);</br>插入:appendChild（）；//添加到末尾</br>InsertBefore（'子节点'，'在谁之前'）；</br>removeChild（）；//移除</br>replaceChild（'新的元素节点'，'需替换的节点'）；</br>文档碎片:CreateDocumentFragment（）；//用于批量创建元素优化</br>Var li=document.createElement（'li'）;</br>Var frag=document.createDocumentFragment;</br>For(var i=0;i<10000;i++){</br>Frag.appendChild(li);</br>}</br>Ul.appendChild(frag);</p></details><details open><summary>表格获取方法</summary><p>var tab=document.getElementById('tab');//首先获取表单元素</br>Tab.tBodies[0].rows[i].cells[i]//rows表示行，cells表示列</p></details><details open><summary>视口坐标与尺寸</summary><p>获取页面滚动距离：var scrolltop=document.documentElement.scrollTop||document.body.scrollTop//兼容写法</br>视口尺寸：var w=document.documentElement.clientWidth||document.body.clientWidth//兼容写法</p></details><details open><summary>HTML表单</summary><p><img src='note/input1.png' style='display:block' /></p></details>","<h3>1 传统事件类型</h3><details open><summary>表单事件</summary><p>form元素会触发submit和reset</br>按钮表单元素会触发onclick事件</br>其他表单会触发onchange事件</br>文字输入类表单得到和失去焦点时会本别触发onfocus和onblur事件，这两种事件不会冒泡</p></details><details open><summary>window事件</summary><p>load:当文档和其他所有外部资源完全加载完毕并显示给用户时就会触发</br>unload:当用户离开文档或者转向其他文档时触发,一般用于保存用户状态</br>beforeunload:和unload相似，但是能提供询问用户是否确认离开此页的机会。</br>resize和scroll：浏览器窗口大小调整和滚动相应触发的事件</br>鼠标事件:clientX和clientY指定了鼠标相对于窗口的坐标，鼠标移动是会触发mousemove事件，鼠标抬起和放下相应触发mousedown和mouseup事件，鼠标点击和双击触发click和dbclick事件，鼠标右键触发contextmenu事件</br>键盘事件：keyCode用来获取对应键的编码，键盘按下抬起分别触发keydown和keyup，keypress事件对象指定产生的字符而并非按下的键</p></details><h3>2 事件注册</h3><details open><summary>addEventListener</summary><p>除了ie8之前所有浏览器都支持，这个方法可以为事件目标注册事件处理程序，addEventListener接受3个参数，第一个事件类型但是没有on，第二个调用的函数，三个是布尔值，true，表示在捕获阶段调用事件处理程序；如果是false，表示在冒泡阶段调用事件处理程序</br>removeEventListener():移除注册事件，可传参数依然为3个和addEventListener相同</p></details><details open><summary>attachEvent</summary><p>IE9之前不支持addEventListener方法，所有IE9之前都使用attachEvnet方法，但是attachEvent方法不支持事件捕获，IE9之前事件捕获使用obj.setCapture()解除事件捕获使用obj.releaseCapture()</br>attachEvent传入2个参数，第一个事件类型需要带on，第二个调用的函数</br>解除注册使用detachEvent方法，传入参数与attachEvent方法相同<img src='note/attach.png' style='display:block' /></p></details><details open><summary>事件取消</summary><p>在支持attachEventListener()的浏览器当中使用event.preventDefault()来阻止默认事件,在IE9之前使用event.returnValue=false</br>function cancelHandler(e){</br>&nbsp&nbspvar e=e||event;</br>&nbsp&nbspif(e.preventDefault)e.preventDefault();//标准技术</br>&nbsp&nbspif(e.returnValue)e.returnValue=false;//IE</br>&nbsp&nbspreturn false;//用于处理使用对象属性注册的处理技术</br>}</p></details><details open><summary>取消冒泡事件</summary><p>在支持attachEventListener()的浏览器当中使用event.stopPropagation()来阻止冒泡事件，在IE9之前的浏览器使用event.cancelBubble=true取消事件的传播</p></details><details open><summary>文档加载事件</summary><p>document.readyState属性伴随着文档加载过程而改变,每一次状态改变都伴随着Document对象上的readystatechange事件</br>uninitialized - 还未开始载入</br>loading - 载入中</br>interactive - 已加载，文档与用户可以开始交互</br>complete - 载入完成</p></details><details open><summary>鼠标滚轮事件</summary><p>除了火狐以外所有浏览器都支持mousewheel事件，而火狐使用的是DOMMouseSroll。mousewheel事件对象有wheelDelta属性，指定用户滚动滚轮有多远，向上滚动的的值是120，向下滚动的值是-120。而在DOMMouseScroll中detail属性代替了wheelDelta，向上滚动是-3,向下滚动是3<img src='note/mousewheel.png' style='display:block' /></p></details>","<h3>1 Ajax</h3>异步加载:异步 javascript and xml,通过脚本操纵HTTP，下面介绍ajax的使用步骤<details open><summary>1.创建XMLHttpRequest对象</summary><p>var xmlhttp;</br>if (window.XMLHttpRequest)</br>{// code for IE7+, Firefox, Chrome, Opera, Safari</br>&nbsp&nbsp&nbsp&nbspxmlhttp=new XMLHttpRequest();</br>}</br>else</br>{// code for IE6, IE5</br>&nbsp&nbsp&nbsp&nbspxmlhttp=new ActiveXObject('Microsoft.XMLHTTP');</br>}</br></p></details><details open><summary>2.指定请求</summary><p>通过open的方式确定访问的页面</br>xmlhttp.open('GET','url',true);//open的几个参数：第一个表示请求类型，第二个表示提交的地址，第三个表示是否使用异步</br>请求类型主要分成2中get和post，两者区别：<img src='note/get.png' style='display:block' /></p></details><details open><summary>3.发送请求</summary><p>xmlhttp.setRequestHeader('Content-type: text/html;charset=utf-8','application/x-www-form-urlencoded');//设置请求头类型为字符串</br>xmlhttp.send('id=123');//发送一段字符串</br>//get方法传入在第二个参数中添加？</br>xmlhttp.open('GET','url?id=123',ture);</br></p></details><details open><summary>4.得到响应</summary><p>xmlhttp.onreadystatechange=function(){//当每次xmlhttp。readyState属性改变时都会运行下面的函数，所以下面进行了if判断</br>&nbsp&nbsp&nbsp&nbspif (xmlhttp.readyState==4 && xmlhttp.status==200)//否则弹5次、每个readyState改变时运行一次alert</br>&nbsp&nbsp&nbsp&nbsp{</br>&nbsp&nbsp&nbsp&nbspalert('ok');</br>&nbsp&nbsp&nbsp&nbsp}</br>}</br>xml.responseText得到的是文本形式，xml.responeXML得到的是Document形式的</br>关于readyState和status：<img src='note/readystate.png' style='display:block' /></p></details>","<h3>1 cookie</h3>cookie页面用来保存信息,同一个域名共享一套cookie，大小不超过4K，容量小，有过期时间<details open><summary>document.cookie</summary><p>document.cookie='键名=值;max-age=seconds'//这样就设置了cookie，默认存在时间直至浏览器关闭</br>document.cookie返回的的字符串，如果要获取需要使用split(';')首先分割每一个cookie数据，然后split('=')分离键值</p></details>"],
                name:"原生Javascript"
                }
            ],[
                {dt:"jQuery基础",
                dl:["JQ概述","JQ函数"],
                text:[
                "<h3>1.jQuery基础</h3><div>jQuery定义了一个全局函数：jQuery(),因此还定义了另一个快捷别名$,这是JQ在全局命名空间中定义的唯一两个变量</br>var div=$('div')返回的是文档中所有div标签元素，JQ是工厂函数不是构造函数，返回的是新创建的对象。</br>JQ链式调用:$('div').css('background','red').show('fast')</br>JQ每一个方法都返回了这个对象所以可以链式调用。</br>Jquery 1和2版本区别在于2不支持IE678</div>","<h3>1.Jquery函数</h3><div>JQuery重要的方法就是jquery()，有4中不同的调用方式</br>第一种就是传递css选择器给$()方法会返回当前文档相应匹配的元素集：$('#main')</br>第二种调用方法就是传递element,document或者window对象给$()方法，JQ会将element,document或者window对象封装成JQ对象并返回：$(this)、$(document)</br>第三中方法是传递HTML标签给$()方法，此方法还可以接收第二个参数object对象用来设置HTML标签的属性：$('<img />',{src:url,css:{brderWidth:5},click:fn})</br>第四种方法是传入函数：</br>JQuerydom加载完毕时调用的3中写法:</br>1:$().ready(fn)</br>2.$(fn)</br>3.$(document).ready(fn)</br>与JS中window.onload不同JQready方式是文档中的bom元素加载完成时就会调用(不包括文字和图片内容)，而window.onload是指页面所有元素加载完毕时调用,所以说ready会在window.onload前调用</div><h3>1.1查询与查询结果</h3><div>JQ返回的是数组对象：所以他们就拥有length和下标属性:</br>$('body').length //----1</br>$('body')[0] //等于document.body</br>但是JQ有size()方法替代length，eq()方法替代下标</div><h3>1.2 JQ的遍历</h3><div>JQ中有each方法替代for循环<img src='note/each.png' style='display:block' width=650 /></div>"],
                name:"JQuery"
                },
                {dt:"jQuery中的获取与赋值",
                dl:["获取和设置HTML属性","获取和设置CSS","获取和设置表单值","获取和设置元素内容","获取和设置元素位置宽高","设置元素数据"],
                text:[
                "<h3>1.attr()方法</h3><div>JQ中attr()方法来替代js中getattribute和setattribute方法用来设置和获取标签的属性，removeAttr()方法用来代替removeAttribute用来移除标签的属性</div><img src='note/attr.png' style='display:block' width=650 />","<h3>1.css()方法</h3><div>JQ中css()方法来替代js中obj.style.css属性单一的设置css样式，可以使用对象的方式传参设置多个css样式，支持原css方式如margin-top或者JS的驼峰样式backgroundColor,css()会将数值自动转换成带单位的字符串</div><img src='note/css.png' style='display:block' width=650 /><h3>2.获取和设置css类</h3><div>JS中使用className来获取或设置类名，而JQ中操作是设置css类的方法确有多种多样</div><img src='note/class.png' style='display:block' width=650 />","<h3>1.获取各种表单值</h3><div>JQ中val()方法来替代js中input.value属性获取和设置表单值</div><img src='note/val.png' style='display:block' />","<h3>1.设置和获取元素内容</h3><div>JQ中提供了text()和html()方法来设置，text()是设置该对象的文本内容,而html()则相当于JS中的innerHTML，可以格式化对象的的内容</div><img src='note/text.jpg' style='display:block' />","<h3>1.获取和设置元素的位置和宽高</h3><div>JQ中提供了大量的方法来获取元素的值</div><img src='note/offset.png' style='display:block' />","<h3>1.data()</h3><div>JQ中提供了data()方法可以设置和读取对象自定义的数据，removeData用来删除设置的数据</div><img src='note/data.png' style='display:block' />"],
                name:"JQuery"
                },
                {dt:"DOM操作",
                dl:["插入和替换元素","复制元素","包装元素","删除元素"],
                text:[
                " <h3>1.插入和替换元素</h3><div>JQ中提供了一系列方法用来插入和修改元素</div><img src='note/append.png' style='display:block' />","<h3>1.clone()</h3><div>JQ中存在clone方法可以克隆该元素，但是默认不会clone该元素的事件和其他管理的数据如果需要克隆事件需要传入参数true</div><iframe scrolling='no' width=500 height=160 src='clone.html'></iframe><img src='note/clone.png' width=650 style='display:block' />","<h3>1.包装元素</h3><div>JQ中定义了3个方法用来包装元素</br>wrap():在元素的外部包裹内容</br>wrapInner():在元素内部包裹内容</br>wrapAll():在元素外部包裹所有</div><img src='note/wrap.png' style='display:block' />","<h3>1.删除元素</h3><div>JQ中定义了3个方法用来包装元素</br>empty():清空该对象内的所有子元素</br>remove()移除该对象和该对象绑定的事件和数据.detach()方法和remove类似，但是不会移除事件和数据</br>unwrap()是wrap和wrapAll的反操作：移除该元素的父级元素</div><iframe scrolling='no' width=200 height=286 src='remove.html'></iframe><img src='note/remove.jpg' style='display:block' />"],
                name:"JQuery"
                },
                {dt:"JQ处理事件",
                dl:["事件的简单注册","高级注册"],
                text:[
                "<h3>1.Jq中的事件</h3><div>JQ定义了许多简单的事件,如下</div><img src='note/event.png' width=650 style='display:block' />","<h3>JQ的事件绑定与解除</h3><div>JQ中定义了bind()方法来代替JS中addEventListener用来事件的高级注册，bind()用法如下:</br><div class='dmshow'>$('#div').bind('click',function(){alert(this)})</br>//为id为DIV的元素绑定一个点击事件</div></div><h3>unbind方法是对bind的反操作，用来解除绑定</h3><div class='dmshow'>$('#div').unbind('click')</br>//解除id为DIV的元素绑定的点击事件</div>"],
                name:"JQuery"
                },
                {dt:"JQ动画",
                dl:["简单的动画","自定义动画","动画的取消、延迟和队列"],
                text:[
                "<h3>JQ中简单的动画效果</h3><div>JQ中封装了9个简单的动画方法，用来隐藏和显示元素，下面将分为3组介绍:</div><details open><summary>fadeIn,fadeOut,fadeTo</summary><p>fadeIn和fadeOut是通过控制opocity来显示和隐藏元素，接受的参数可以选填时间单位为毫秒和回调函数，fadeTo是指opacity变化到目标值,接受的三个参数为时长，目标值和回调函数</p></details><details open><summary>show,hide,toggle</summary><p>show和hide方法用来控制元素立即显示可隐藏,相当于css当中display:none或者block/inline。toggle则是改变元素的显示状态,如果显示则隐藏如果隐藏则显示</p></details><details open><summary>slideDown,slideUp,slideToggle</summary><p>slideUp,是将元素的高度动态变化为0，然后将其display:none，slideDown则是其反操作，toggle则是检测向上滑动或向下滑动切换</p></details>","<h3>自定义动画</h3><div>JQ中提供了animate()方法用来自定义动画效果</div><details open><summary>animate()的使用</summary><p>animate,可以接受3个参数，第一个参数是已对象的形式传入，是指元素改变的属性和目标值，目标值还可以填写show和hide，第二个参数指的是动画运动的时间，第三个参数表示运动完成后回调函数</p></details><iframe src='animate.html' frameborder='no' scrolling='no' width=650 height=500></iframe>","<h3>动画的取消、延迟和队列</h3><details open><summary>stop()</summary><p>当stop不传参数时，会直接取消之前的动画，执行最后一个动画效果,stop方法可以传2个参数，都是布尔值，如果只传入一个true，就会停止动画，停留在停止动画前的数值上，如果填写2个true，就会直接完成所有动画效果</p></details><details open><summary>delay()</summary><p>设置延迟时间，相当于timeout，传入参数为时间</p></details><details open><summary>queque()</summary><p>queque是指动画队列，queque有Length属性，返回的是该元素的动画队列个数,queque用方法是传入函数</br>$('#div').queue(function(next){//这里面可以设置一些方法在动画执行前运行</br>next()//如果不填写后面的animate就不会执行，也可以用$(this).dequeue()代替}).animate()</details>"],
                name:"JQuery"
                },
                {dt:"JQ中的Ajax",
                dl:["JQ中的Ajax"],
                text:[
                "<h3>Ajax介绍</h3>Ajax 全称为：“Asynchronous JavaScript and XML”（异步JavaScript 和XML）<details open><summary>Ajax流程</summary><p>a.JavaScript，通过用户或其他与浏览器相关事件捕获交互行为<br>b.XMLHttpRequest 对象，通过这个对象可以在不中断其它浏览器任务的情况下向服务器发送请求；<br>c.服务器上的文件，以XML、HTML 或JSON 格式保存文本数据；<br>d.其它JavaScript，解释来自服务器的数据并将其呈现到页面上</p></details><details open><summary>JQ中的ajax方法</summary><p>$.ajax()<br>$.ajax({</br>&nbsp&nbsptype:‘’, //请求方式（post或get）<br>&nbsp&nbsp url:‘’, //请求的路径<br>&nbsp&nbspdata:{data1:value1,data2:value2}, //传递给服务器数据<br>&nbsp&nbspsuccess:function(data){ //异步成功后的回调函数<br>&nbsp&nbsp&nbsp&nbspalert(data);<br>});<br><br>$.getJSON()</br>$.getJSON(url,function(data){<br>//参数1：JSON文件路径<br>//参数2：回调函数，data响应信息<br>}); <br></p></details>"],
                name:"JQuery"
                }
            ]
        ];